<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Отчет: Методы численного интегрирования</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f8f9fa;
        }

        header {
            background: linear-gradient(135deg, #2c3e50 0%, #4a6491 100%);
            color: white;
            padding: 30px;
            border-radius: 10px;
            margin-bottom: 30px;
        }

        h1 {
            margin: 0;
            font-size: 2.5em;
            text-align: center;
        }

        .subtitle {
            text-align: center;
            font-style: italic;
            margin-top: 10px;
            opacity: 0.9;
        }

        section {
            background: white;
            padding: 25px;
            margin-bottom: 25px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            border-left: 4px solid #3498db;
        }

        h2 {
            color: #2c3e50;
            border-bottom: 2px solid #ecf0f1;
            padding-bottom: 10px;
            margin-top: 0;
        }

        h3 {
            color: #34495e;
            margin-top: 25px;
        }

        .method-card {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            padding: 20px;
            margin: 15px 0;
        }

        .method-name {
            color: #2980b9;
            font-weight: bold;
            font-size: 1.2em;
            margin-bottom: 10px;
        }

        .complexity {
            display: inline-block;
            background: #e74c3c;
            color: white;
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 0.85em;
            margin-left: 10px;
        }

        .results-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }

        .results-table th {
            background-color: #34495e;
            color: white;
            text-align: left;
            padding: 12px;
        }

        .results-table td {
            padding: 10px 12px;
            border-bottom: 1px solid #ddd;
        }

        .results-table tr:nth-child(even) {
            background-color: #f9f9f9;
        }

        .time-cell {
            font-weight: bold;
            color: #27ae60;
        }

        .fastest {
            background-color: #d4edda !important;
            border-left: 4px solid #28a745;
        }

        .nogil-section {
            border-left: 4px solid #e74c3c;
        }

        .note-box {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 6px;
            padding: 15px;
            margin: 15px 0;
        }

        .warning-box {
            background: #f8d7da;
            border: 1px solid #f5c6cb;
            border-radius: 6px;
            padding: 15px;
            margin: 15px 0;
        }

        .code-snippet {
            background: #2d3e50;
            color: #ecf0f1;
            padding: 15px;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            overflow-x: auto;
            margin: 15px 0;
        }

        .recommendation {
            background: #d1ecf1;
            border: 1px solid #bee5eb;
            border-radius: 6px;
            padding: 15px;
            margin: 15px 0;
        }

        .key-point {
            font-weight: bold;
            color: #e74c3c;
        }

        footer {
            text-align: center;
            margin-top: 40px;
            padding-top: 20px;
            border-top: 1px solid #ddd;
            color: #7f8c8d;
            font-size: 0.9em;
        }

        .threads-table {
            width: 100%;
            margin: 20px 0;
            background: #f8f9fa;
            border-radius: 6px;
            overflow: hidden;
        }

        .threads-table th {
            background: #495057;
            color: white;
            padding: 10px;
        }

        .threads-table td {
            padding: 10px;
            border-bottom: 1px solid #dee2e6;
        }
    </style>
</head>
<body>
    <header>
        <h1>Отчет по лабораточной работе №10</h1>
        <div class="subtitle">Интеграрование потоками, процессами, переводом на С и обходом GIL</div>
    </header>

    <section>
        <h2>1. Краткое описание методов</h2>

        <div class="method-card">
            <div class="method-name">1.1. Базовый метод (integrate)</div>
            <p><strong>Алгоритм:</strong> Метод левых прямоугольников</p>
            <ul>
                <li>Итеративный подход без параллелизации</li>
                <li>Минимальные накладные расходы</li>
            </ul>
        </div>

        <div class="method-card">
            <div class="method-name">1.2. Параллельный метод с потоками (integrate_async)</div>
            <p><strong>Алгоритм:</strong> ThreadPoolExecutor с разделением отрезка</p>
            <ul>
                <li>Разделяет отрезок интегрирования на n_jobs частей</li>
                <li>Каждая часть вычисляется в отдельном потоке</li>
                <li>Ограничен GIL (Global Interpreter Lock)</li>
            </ul>
        </div>

        <div class="method-card">
            <div class="method-name">1.3. Параллельный метод с процессами (integrate_process)</div>
            <p><strong>Алгоритм:</strong> ProcessPoolExecutor с разделением отрезка</p>
            <ul>
                <li>Разделяет отрезок интегрирования на n_jobs частей</li>
                <li>Каждая часть вычисляется в отдельном процессе</li>
                <li>Обходит ограничение GIL</li>
            </ul>
        </div>

        <div class="method-card">
            <div class="method-name">1.4. Оптимизированный метод на Cython (integrate_cython)</div>
            <p><strong>Алгоритм:</strong> Компилируемая версия метода левых прямоугольников</p>
            <ul>
                <li>Статическая типизация C-переменных</li>
                <li>Директивы: boundscheck=False, wraparound=False, cdivision=True</li>
            </ul>
        </div>

        <div class="method-card nogil-section">
            <div class="method-name">1.5. Мультипроцессинг как аналог noGIL (integrate_processes_mp)</div>
            <p><strong>Алгоритм:</strong> multiprocessing с разделением отрезка</p>
            <ul>
                <li>Использует модуль multiprocessing напрямую</li>
                <li>Каждая часть вычисляется в отдельном процессе</li>
                <li>Полностью обходит ограничения GIL</li>
                <li>Аналогичен работе потоков в режиме noGIL</li>
            </ul>
            <div class="code-snippet">
<pre>def integrate_processes_mp(f, a, b, *, n_jobs=2, n_iter=1000):
    result_queue = mp.Queue()
    processes = []

    step = (b - a) / n_jobs
    seg_iter = n_iter // n_jobs

    for i in range(n_jobs):
        a_seg = a + i * step
        b_seg = a + (i + 1) * step

        p = mp.Process(
            target=worker,
            args=(f, a_seg, b_seg, seg_iter, result_queue, i)
        )
        processes.append(p)
        p.start()

    results = [0.0] * n_jobs
    for _ in range(n_jobs):
        idx, result = result_queue.get()
        results[idx] = result

    for p in processes:
        p.join()

    return sum(results)</pre>
</div>
        </div>
    </section>

    <section>
        <h2>2. Результаты тестирования</h2>

        <h3>2.1. Корректность вычислений</h3>
        <p>Все реализации успешно прошли тесты:</p>
        <ul>
            <li>Интеграл sin(x) от 0 до π: ожидается 2.00000</li>
            <li>Все методы дают одинаковый результат с точностью до 5 знаков</li>
        </ul>

        <h3>2.2. Производительность (10,000,000 итераций)</h3>
        <p>Интеграл sin(x) от 0 до π:</p>

        <table class="results-table">
            <thead>
                <tr>
                    <th>Метод</th>
                    <th>Время выполнения</th>
                    <th>Результат</th>
                    <th>Ускорение</th>
                    <th>Примечания</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>Integrate_1 (базовый)</td>
                    <td class="time-cell">0.6347 сек</td>
                    <td>2.00000</td>
                    <td>1.00x</td>
                    <td>Последовательное выполнение</td>
                </tr>
                <tr>
                    <td>Integrate_async (потоки)</td>
                    <td class="time-cell">0.5785 сек</td>
                    <td>2.00000</td>
                    <td>1.10x</td>
                    <td>Ограничен GIL</td>
                </tr>
                <tr>
                    <td>Integrate_cython (Cython)</td>
                    <td class="time-cell">0.6058 сек</td>
                    <td>2.00000</td>
                    <td>1.05x</td>
                    <td>Компиляция в C-код</td>
                </tr>
                <tr>
                    <td>Integrate_process (процессы)</td>
                    <td class="time-cell">0.3741 сек</td>
                    <td>2.00000</td>
                    <td>1.70x</td>
                    <td>ProcessPoolExecutor</td>
                </tr>
                <tr class="fastest">
                    <td><strong>Integrate_5_processes_mp (2 процесса)</strong></td>
                    <td class="time-cell"><strong>0.3823 сек</strong></td>
                    <td><strong>2.00000</strong></td>
                    <td><strong>1.66x</strong></td>
                    <td><strong>Аналог noGIL</strong></td>
                </tr>
            </tbody>
        </table>
    </section>

    <section class="nogil-section">
        <h2>3. Анализ noGIL и многопоточности</h2>

        <h3>3.1. Тестирование с разным количеством процессов (аналог noGIL)</h3>

        <table class="threads-table">
            <thead>
                <tr>
                    <th>Количество процессов</th>
                    <th>Время выполнения</th>
                    <th>Ускорение относительно базового</th>
                    <th>Примечания</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>2 процесса</td>
                    <td>0.3994 сек</td>
                    <td>1.59x</td>
                    <td>Уже лучше потоков с GIL</td>
                </tr>
                <tr>
                    <td>4 процесса</td>
                    <td>0.2623 сек</td>
                    <td>2.42x</td>
                    <td>Значительное улучшение</td>
                </tr>
                <tr class="fastest">
                    <td><strong>6 процессов</strong></td>
                    <td><strong>0.2418 сек</strong></td>
                    <td><strong>2.63x</strong></td>
                    <td><strong>Оптимальное количество</strong></td>
                </tr>
                <tr>
                    <td>8 процессов</td>
                    <td>0.2424 сек</td>
                    <td>2.62x</td>
                    <td>Плато производительности</td>
                </tr>
                <tr>
                    <td>10 процессов</td>
                    <td>0.2542 сек</td>
                    <td>2.50x</td>
                    <td>Накладные расходы</td>
                </tr>
            </tbody>
        </table>

        <h3>3.2. Почему noGIL увеличивает скорость до 6-8 потоков</h3>

        <div class="method-card">
            <div class="method-name">Принцип работы noGIL</div>
            <p>noGIL (No Global Interpreter Lock) позволяет потокам Python выполняться действительно параллельно, а не последовательно, как при обычном GIL.</p>

            <p><strong>Наблюдения из тестов:</strong></p>
            <ol>
                <li><strong>2 процесса:</strong> 1.59x ускорение - уже лучше потоков с GIL</li>
                <li><strong>4 процесса:</strong> 2.42x ускорение - почти линейное масштабирование</li>
                <li><strong>6 процессов:</strong> 2.63x ускорение - оптимальная точка</li>
                <li><strong>8+ процессов:</strong> уменьшение производительности</li>
            </ol>
        </div>

        <div class="note-box">
            <strong>Наблюдение №1:</strong> После 6 процессов время выполнения практически не уменьшается (0.2418 сек для 6 процессов vs 0.2424 сек для 8 процессов). Это связано с:
            <ul>
                <li>Накладными расходами на создание и управление процессами</li>
                <li>Конкуренцией за ресурсы CPU и память</li>
                <li>Физическими ограничениями процессора (количество ядер/потоков)</li>
            </ul>
        </div>
        <div class="note-box">
            <strong>Наблюдение №2:</strong> Cython интегрирование - это один из самых эффективных методов, так как чистый С быстрее Python, но код для полной компиляции кода неидеален. Это связано с:
            <ul>
                <li>Несовершенный перевод кода питона на С</li>
                <li>Разная логика у двух языков, что замедляет работу на С</li>
            </ul>
        </div>

        <h3>3.3. Сравнение с потоками (ограниченными GIL)</h3>
        <div class="warning-box">
            <strong>Потоки с GIL:</strong> 0.5785 сек (всего 1.10x ускорение даже при 2 потоках)<br>
            <strong>Процессы (аналог noGIL):</strong> 0.2418 сек (2.63x ускорение при 6 процессах)<br><br>
            Разница в производительности в <strong>2.39 раза</strong> показывает эффективность обхода GIL.
        </div>
    </section>

    <section>
        <h2>4. Как применять</h2>

        <div class="recommendation">
            <h3>Для CPU-bound (ограничены производительностью процессора) вычислений (интегрирование):</h3>
            <p>Использовать <span class="key-point">multiprocessing с 6 процессами</span> (аналог noGIL) для максимальной производительности.</p>
        </div>

        <div class="recommendation">
            <h3>Оптимальное количество процессов:</h3>
            <p><span class="key-point">6 процессов</span> показало наилучшее время выполнения (0.2418 сек). Большее количество не дает значительного улучшения.</p>
        </div>

        <div class="recommendation">
            <h3>Когда использовать потоки:</h3>
            <p>Только для <span class="key-point">I/O-bound задач (ожидание операций ввода-вывода)</span>. Для вычислений потоки ограничены GIL.</p>
        </div>

        <h3>Выводы по noGIL:</h3>
        <ol>
            <li>noGIL (или его аналог multiprocessing) существенно ускоряет CPU-bound вычисления</li>
            <li>Оптимальное ускорение достигается при 6 параллельных процессах/потоках</li>
            <li>Дальнейшее увеличение количества процессов не эффективно из-за накладных расходов</li>
            <li>Мультипроцессинг дает аналогичный noGIL результат без специальной сборки Python</li>
        </ol>
    </section>

    <section>
        <h2>5. Итоговый вывод</h2>

        <p><strong>Основные результаты исследования:</strong></p>

        <div class="method-card">
            <div class="method-name">noGIL (через multiprocessing) - наиболее эффективен</div>
            <p>Достигнуто ускорение в 2.63 раза при 6 процессах. Показывает, как могла бы работать многопоточность без GIL.</p>
        </div>

        <div class="method-card">
            <div class="method-name">Производительность после 6 процессов</div>
            <p>Оптимальное количество параллельных задач для данной вычислительной нагрузки - 6. Дальнейшее увеличение не эффективно.</p>
        </div>

        <div class="method-card">
            <div class="method-name">GIL - основное ограничение потоков Python</div>
            <p>Потоки дают лишь 10% ускорение для CPU-bound задач, тогда как процессы (без GIL) - 163%.</p>
        </div>

        <p>Для задач численного интегрирования можно использовать <span class="key-point">multiprocessing с 6 процессами</span> как оптимальное решение, дающее максимальное ускорение при разумных накладных расходах. Это решение работает без необходимости установки специальных версий Python с NOGIL и дает сравнимую производительность, потому что noGIL подключить было сложно, а структура работы этих методов схожа.</p>
    </section>
    <script>
        // Установка текущей даты
        const now = new Date();
        const options = { year: 'numeric', month: 'long', day: 'numeric' };
        document.getElementById('current-date').textContent = now.toLocaleDateString('ru-RU', options);
    </script>
</body>
</html>
